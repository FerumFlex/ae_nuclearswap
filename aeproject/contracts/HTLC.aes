@compiler >= 6

include "Option.aes"
include "String.aes"

contract interface FungibleTokenInterface =
  record meta_info =
    { name : string
    , symbol : string
    , decimals : int }
  record allowance_accounts = { from_account : address, for_account : address }

  datatype event =
    Transfer(address, address, int)
    | Allowance(address, address, int)

  entrypoint aex9_extensions : ()                         => list(string)
  entrypoint meta_info       : ()                         => meta_info
  entrypoint total_supply    : ()                         => int
  entrypoint owner           : ()                         => address
  entrypoint balances        : ()                         => map(address, int)
  entrypoint balance         : (address)                  => option(int)
  entrypoint allowance       : (allowance_accounts)         => option(int)
  stateful entrypoint transfer_allowance : (address, address, int) => unit
  stateful entrypoint transfer        : (address, int)             => unit


contract HTLC =
  datatype event =
    // Log_fund(hash, indexed address, hash, indexed address, indexed address, int, int)
    Log_fund(hash, address, address)
    | Log_withdraw(hash)
    | Log_refund(hash)

  record lockContract =
    { token : FungibleTokenInterface
    , secret_hash : hash
    , recipient : address
    , sender : address
    , endtime : int
    , amount : int
    , withdrawn : bool
    , refunded : bool
    , preimage : string }

  type locked_contracts = map(hash, lockContract)

  record state =
    { locked_contracts: locked_contracts }

  entrypoint init() =
    { locked_contracts = {} }

  function is_token_transferable(token: FungibleTokenInterface, sender: address, amount: int ) =
    require(amount > 0, "token amount must be > 0")
    let allowed = Option.default(0, token.allowance({ from_account = sender, for_account = Contract.address }))
    require(allowed >= amount, "token allowance must be >= amount")

  function future_endtime(endtime : int) =
    require(endtime > Chain.timestamp, "endtime time must be in the future")

  function is_locked_contract_exist(locked_contract_id: hash) =
    require(have_locked_contract(locked_contract_id), "locked_contract_id does not exist")

  function check_secret_hash_matches(locked_contract_id : hash, preimage : string) =
    let locked_contract = state.locked_contracts[locked_contract_id]
    require(locked_contract.secret_hash == Crypto.sha256(preimage), "secret hash hash does not match")

  function withdrawable(locked_contract_id : hash) =
    let locked_contract = state.locked_contracts[locked_contract_id]
    require(locked_contract.recipient == Call.caller, "withdrawable: not recipient")
    require(locked_contract.withdrawn == false, "withdrawable: already withdrawn")
    require(locked_contract.refunded == false, "withdrawable: already refunded")

  function refundable(locked_contract_id : hash) =
    let locked_contract = state.locked_contracts[locked_contract_id]
    require(locked_contract.sender == Call.caller, "refundable: not sender")
    require(locked_contract.refunded == false, "refundable: already refunded")
    require(locked_contract.withdrawn == false, "refundable: already withdrawn")
    require(locked_contract.endtime =< Chain.timestamp, "refundable: endtime not yet passed")

  stateful entrypoint fund(token: FungibleTokenInterface , secret_hash : hash , recipient : address, endtime : int, amount : int) : hash =
    is_token_transferable (token, Call.caller, amount)
    future_endtime (endtime)

    let sender = Call.caller
    let parts =
      [ Address.to_str(token.address)
        ,Bytes.to_str(secret_hash)
        ,Address.to_str(recipient)
        ,Address.to_str(sender)
        ,Int.to_str(endtime)
        ,Int.to_str(amount)]
    let locked_contract_id = Crypto.sha256(String.concats(parts))

    if (have_locked_contract(locked_contract_id))
      abort("this locked contract already exists")

    token.transfer_allowance(sender, Contract.address, amount)

    put(state{ locked_contracts[locked_contract_id] = {token = token, secret_hash = secret_hash, recipient = recipient, sender = sender, endtime = endtime, amount = amount, withdrawn = false, refunded = false, preimage = ""}})

    Chain.event(Log_fund(locked_contract_id, recipient, sender))
    locked_contract_id

  stateful entrypoint withdraw(locked_contract_id: hash, preimage: string) : bool =
    is_locked_contract_exist (locked_contract_id)
    check_secret_hash_matches (locked_contract_id, preimage)
    withdrawable (locked_contract_id)

    put(state{ locked_contracts[locked_contract_id].preimage = preimage })
    put(state{ locked_contracts[locked_contract_id].withdrawn = true })

    let locked_contract = state.locked_contracts[locked_contract_id]
    locked_contract.token.transfer(locked_contract.recipient, locked_contract.amount)

    Chain.event(Log_withdraw(locked_contract_id))
    true

  stateful entrypoint refund(locked_contract_id : hash) : bool =
    is_locked_contract_exist (locked_contract_id)
    refundable (locked_contract_id)

    put(state{ locked_contracts[locked_contract_id].refunded = true })

    let locked_contract = state.locked_contracts[locked_contract_id]
    locked_contract.token.transfer(locked_contract.sender, locked_contract.amount)

    Chain.event(Log_refund(locked_contract_id))
    true

  entrypoint get_locked_contract(locked_contract_id : hash) : option(lockContract) =
    Map.lookup(locked_contract_id, state.locked_contracts)

  entrypoint have_locked_contract(locked_contract_id : hash) : bool =
    Map.member(locked_contract_id, state.locked_contracts)
